<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <title>Manipulate Users via SCDS API</title>
	<link href="default.css" rel="stylesheet" type="text/css" />
  </head>
  <body>
	  <div id="header">
		  <div id="logo">
			<h1><a href="#">SCDS API</a></h1>
			<p><span>SkySQL Cloud Data Suite API</span></p>
		  </div>
		  <div id="menu">
			<ul>
			  <li class="active"><a href="index.html">About</a></li>
			  <li><a href="systemform.html">System</a></li>
			  <li><a href="nodeform.html">Node</a></li>
			  <li><a href="userform.html">User</a></li>
			  <li><a href="backupform.html">Backup</a></li>
			  <li><a href="monitorform.html">Monitor</a></li>
			  <li><a href="jobform.html">Job</a></li>
			</ul>
		  </div>
	  </div>	
	<div id="page">
	  <div class="section">
	  <h2>About the API for the SkySQL Cloud Data Suite</h2>
	  <p>
		  The API is a RESTful web service, allowing control of one or more SkySQL
		  Cloud Systems.  A truly RESTful interface relies on a Resource Oriented
		  Architecture, and the SCDS API does that.  Calls are made to different URIs 
		  depending on which resource is being accessed.  Different HTTP methods are 
		  used, in accordance with REST principles:
	  </p>
	  <ul>
		  <li>Retrieve a representation of a resource: HTTP GET</li>
		  <li>Create a new resource: HTTP PUT to a new URI, or HTTP POST to an existing URI</li>
		  <li>Modify an existing resource: HTTP PUT to an existing URI</li>
		  <li>Delete an existing resource: HTTP DELETE</li>
	  </ul>
	  <p>
		  The main resources handled by the SCDS API are Systems, Nodes, Users, Backups,
		  Monitors, Commands/Jobs.  Each has a page where you can run the various API requests.
	  </p>
	  <h3>Resources Managed by the API</h3>
	  <p>
		  Up to now, the main resources that are understood by the API are:
	  </p>
	  <ul>
		  <li>Systems (which also have properties)</li>
		  <li>Nodes</li>
		  <li>Users (which also have properties)</li>
		  <li>Backups</li>
		  <li>Monitor Classes</li>
		  <li>Monitor Instances (which have sets of data associated with them)</li>
		  <li>Commands</li>
		  <li>Jobs</li>
	  </ul>
	  <p>
		  Subsidiary resources are really just lookups for short codes, and they
		  can be processed on the related main resource page:
	  </p>
	  <ul>
		  <li>Backup possible states</li>
		  <li>Node possible states</li>
		  <li>Command possible states</li>
		  <li>Command steps</li>
	  </ul>
	  <p>
		  An oddball that does not altogether fit with the scheme but is included
		  on the Commands page is:<br />
		  bucket<br /><br />
		  There is also an API call on the Commands page to run SQL (limited to 
		  SELECT or SHOW) on the database. Details of the main resources follow.
		  All the main resources can be created, updated or deleted through the API.
	  </p>
	  <h3>Systems</h3>
	  <p>
		  A system is a group of nodes that run database servers in a linked way
		  so as to produce a single integrated database service.  The use of
		  multiple nodes is aimed at solving problems of scaling and load handling.
		  Connected resources are system properties, which are name-value pairs
		  associated with a particular system.  
	  </p>
	  <h3>Nodes</h3>
	  <p>
		  A node is a single &quot;machine&quot; that is part of a system.  It is
		  typically a virtual private server (or VPS) and may be provisioned by
		  the use of cloud services.  Nodes can typically be started and stopped
		  (either deliberately or by accident) without bringing down the system.
		  One node is the master database, but not necessarily always the same
		  node.  Another node (never the master) runs this API.
	  </p>
	  <h3>Users</h3>
	  <p>
		  The API allows users to control the system, and provides user
		  authentication.
	  </p>
	  <h3>Backups</h3>
	  <p>
		  Access to currently existing backups of system and nodes is available
		  through the API.
	  </p>
	  <h3>Monitors</h3>
	  <p>
		  
	  </p>
	  <h3>Commands</h3>
	  <p>
		  
	  </p>
	  <h3>Jobs</h3>
	  <p>
		  
	  </p>
	  <h3>Securing the API</h3>
	  <p>
		  The API is running on a server that is open to the world.  It is therefore
		  undesirable for just anyone to be able to use the API.  To constrain use of
		  the API, some additional headers need to be sent with each request.  The 
		  headers used are the standard HTTP headers Date and Authorization.
	  </p>
	  <p>
		  The Date header should be set with an RFC-2822 date, or something like it.
		  Standard date format in JavaScript is close enough, or PHP will provide it
		  with a call to date(&#039;r&#039;).  
	  </p>
	  <p>
		  The Authorization header is just a little more complicated.  One element is
		  the use of an API key.  The API has a configuration file, /etc/scdsapi/api.ini.
		  Within the configuration file is an apikeys section which contains one or more
		  integers to which are assigned long random strings.  Typically, these are
		  32 character strings created by applying MD5 to some random text string.  But
		  any long string of characters will do.  The integer will be part of the 
		  authorization header and it will be stored in the log with brief information
		  about each request to the API.  So it is possible to use a number of different
		  API keys to track use of the API by different mechanisms.
	  </p>
	  <p>
		  To create the Authorization header, first obtain the RFC-2822 date mentioned above
		  and the request URI, trimmed of any leading and trailing slashes.  The request
		  URI is the part of an absolute URI that comes after the domain.  For example,
		  the request URI for http://eng01.skysql.com/system/123 is the string &quot;/system/123&quot;.
		  Trimmed of leading and trailing slashes, it is &quot;system/123&quot;.
	  </p>
	  <p>
		  The code string needed for authorization is then calculated by first concatenating these
		  three items:
	  </p>
	  <ul>
		  <li>The trimmed request URI</li>
		  <li>The selected API key string</li>
		  <li>RFC-2822 Date</li>
	  </ul>
	  <p>
		  Once the code string has been formed, the whole Authorization header is obtained
		  by concatenating these strings (the first is the literal text required):
	  </p>
	  <ul>
		  <li>api-auth-</li>
		  <li>the integer corresponding to the chosen API key, as a string, e.g. 1</li>
		  <li>a hyphen</li>
		  <li>the code string computed as above</li>
	  </ul>
	  <p>
		  The full header will then be something like:<br />
		  Authorization: api-auth-1-38ef94d18a0680c227a1f48d4072e9f9
	  </p>
	  <h3>Installation</h3>
	  <p>
		  The code can be extracted from the SkySQL repository.  Currently it is found at
		  bzr+ssh://repository.skysql.com/bzr/admin_php/restfulapi.  The files should be 
		  placed in a directory within the web server's document root.  The directory 
		  structure must be preserved.
	  </p>
	  <p>
		  There is a configuration file called api.ini.  This is in the root of the
		  structure in the repository.  It should be checked and modified to suit local
		  requirements.  In particular, the API keys should be changed in order to secure
		  the API.  The file must be moved to /etc/scdsapi/api.ini so that it cannot be
		  served to the web and so that it can be found by the API.
	  </p>
	  <p>
		  One element of api.ini is the directory given in the logging section.  Provided
		  this points to a directory that can be written by the web server, the API will
		  log some of its actions to a file called api.log.
	  </p>
	  <p>
		  Another critical aspect to installing the API code is setting up Apache 
		  mod_rewrite (or its equivalent).  Any URI that does not correspond to an actual
		  file or directory should be rewritten to point to the index.php file in the root
		  of the API directory structure.  Typical rewriting rules for Apache are:
	  </p>
	  <pre>
RewriteCond %{DOCUMENT_ROOT}%{REQUEST_FILENAME} !-f
RewriteCond %{DOCUMENT_ROOT}%{REQUEST_FILENAME} !-d
RewriteRule ^(.*) /index.php [L]
	  </pre>
	  <p>
		  Depending on the web server configuration, it may also be necessary to use URI
		  rewriting to ensure the HTTP headers are available to the API. For PHP running as
		  CGI, this requires something like:
	  </p>
	  <pre>
RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]
RewriteRule .* - [E=HTTP_IF_MODIFIED_SINCE:%{HTTP:If-Modified-Since}]
RewriteRule .* - [E=HTTP_IF_NONE_MATCH:%{HTTP:If-None-Match}]
	  </pre>
	  <p>
	  </p>
	  <h3>Configuring the API</h3>
	  <p>
		  The API has a configuration file called api.ini.  As mentioned above when discussing
		  installation, the configuration file is located at /etc/scdsapi/api.ini and should be
		  readable but not writeable by the web server when it is running the API.
	  </p>
	  <p>
		  The configuration file installed by default will be something like:
	  </p>
	  <pre>
; This is the INI file for the SkySQL Cloud Data Suite API
[database]
; path should become obsolete when all DB access is via the API
path = "/usr/local/skysql/SQLite/AdminConsole/admin"
pdoconnect = "sqlite:/usr/local/skysql/SQLite/AdminConsole/admin"
user = ""
password = ""
[logging]
directory = "/usr/local/skysql/log"
errorlog = yes
erroremail = "someone@example.com"
[shell]
path = "shell/"
[monitor-defaults]
interval = 1800
count = 15
[apikeys]
1 = "1f8d9e040e65d7b105538b1ed0231770"
	  </pre>
	  <p>
		  The path to the SQLite database could be different, but will be set by the SCDS
		  provisioning system.  User and password are not required so long as SQLite is
		  used for the administration database.  If the logging directory is writeable by
		  the web server when running the API, and the errorlog option is set to yes, 
		  information about requests to the API will be recorded there.  If an email
		  address is provided in erroremail, the errors will be mailed to that address.
		  The shell path defines how system calls will be handled by the API.
	  </p>
	  </div>
	</div>
    </body>
</html>
